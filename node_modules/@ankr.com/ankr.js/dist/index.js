"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const axios_1 = __importDefault(require("axios"));
class AnkrProvider {
    /**
     * Constructs an instance of AnkrProvider.
     * @param apiKey The API key for authorization.
     * @param endpoint Ankr Scan MultiChain RPC endpoint.
     */
    constructor(apiKey = "", endpoint = "https://rpc.ankr.com/multichain/") {
        this.url = endpoint + apiKey;
        this.requestConfig = { headers: { 'Content-Type': 'application/json' } };
        this._nextId = 1;
    }
    /**
     * Returns the array of Log matching the filter.
     * @param params A GetLogsRequest object.
     * @returns Promise<GetLogsReply>
     */
    getLogs(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getLogs", params);
        });
    }
    /**
     * Returns the array of Block within specified range.
     * @param params A GetBlocksRequest object.
     * @returns Promise<GetBlocksReply>
     */
    getBlocks(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getBlocks", params);
        });
    }
    /**
     * Returns the Transaction(s) with specified hash among all supported blockchains.
     * @param params A GetTransactionsByHashRequest object.
     * @returns Promise<GetTransactionsByHashReply>
     */
    getTransactionsByHash(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getTransactionsByHash", params);
        });
    }
    /**
     * Returns Transactions of specified address.
     * @param params A GetTransactionsByAddressRequest object.
     * @returns Promise<GetTransactionsByAddressReply>
     */
    getTransactionsByAddress(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getTransactionsByAddress", params);
        });
    }
    /**
     * Returns coin and token balances of the wallet.
     * @param params A GetAccountBalanceRequest object.
     * @returns Promise<Balance[]>
     */
    getAccountBalance(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getAccountBalance", params);
        });
    }
    /**
     * Returns NFT collectibles of the wallet.
     * @param params A GetNFTsByOwnerRequest object.
     * @returns Promise<GetNFTsByOwnerReply>
     */
    getNFTsByOwner(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getNFTsByOwner", params);
        });
    }
    /**
     * Returns NFT's contract metadata.
     * @param params A GetNFTMetadataRequest object.
     * @returns Promise<GetNFTMetadataRequest>
     */
    getNFTMetadata(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send("ankr_getNFTMetadata", params);
        });
    }
    /**
     * Returns NFT's holders.
     * @param params A GetNFTHoldersRequest object.
     * @returns Promise<GetNFTHoldersRequest>
     */
    getNFTHolders(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.send("ankr_getNFTHolders", params);
        });
    }
    /**
     * Returns list of token holders.
     * @param params A GetTokenHoldersRequest object.
     * @returns Promise<GetTokenHoldersReply>
     */
    getTokenHolders(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getTokenHolders", params);
        });
    }
    /**
     * Returns list of historical token holders count by day.
     * @param params A GetTokenHoldersCountRequest object.
     * @returns Promise<GetTokenHoldersCountReply>
     */
    getTokenHoldersCount(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getTokenHoldersCount", params);
        });
    }
    /**
     * Returns token USD price.
     * @param params A GetTokenPriceRequest object.
     * @returns Promise<GetTokenPriceReply>
     */
    getTokenPrice(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getTokenPrice", params);
        });
    }
    /**
     * Returns list of currencies.
     * @param params A GetCurrenciesRequest object.
     * @returns Promise<GetCurrenciesReply>
     */
    getCurrencies(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getCurrencies", params);
        });
    }
    /**
     * Shows price history for provided token on specific chain
     * @param params A GetTokenPriceHistoryRequest object.
     * @returns Promise<GetTokenPriceHistoryReply>
     */
    getTokenPriceHistory(params) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.send("ankr_getTokenPriceHistory", params);
        });
    }
    send(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = { method, params, id: (this._nextId++), jsonrpc: "2.0" };
            const response = yield axios_1.default.post(this.url, JSON.stringify(request), this.requestConfig);
            return AnkrProvider.getResult(response.data);
        });
    }
    static getResult(payload) {
        if (payload.error) {
            const error = new Error(payload.error.message);
            error.code = payload.error.code;
            error.data = payload.error.data;
            throw error;
        }
        return payload.result;
    }
}
exports.default = AnkrProvider;
//# sourceMappingURL=index.js.map