"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.integrateNextApp = void 0;
const os = __importStar(require("os"));
const cross_spawn_1 = __importDefault(require("cross-spawn"));
const glob_1 = __importDefault(require("glob"));
const fs = __importStar(require("fs"));
const path_1 = __importDefault(require("path"));
const manipulate_next_config_1 = require("./utils/manipulate-next-config");
const yarn_or_npm_1 = require("./utils/yarn-or-npm");
const create_folder_if_not_exists_1 = require("./utils/create-folder-if-not-exists");
const chalk_1 = __importDefault(require("chalk"));
const MakeswiftError_1 = __importDefault(require("./errors/MakeswiftError"));
function generateTemporaryApp({ dir }) {
    const temporaryDirectory = fs.mkdtempSync(os.tmpdir());
    const pagesFolder = getPagesFolder({ dir, temporaryDir: temporaryDirectory });
    (0, create_folder_if_not_exists_1.createFolderIfNotExists)(pagesFolder.temporary);
    return temporaryDirectory;
}
function overwriteIntegratedFiles({ dir, temporaryDir }) {
    const makeswiftFiles = readAllFilesInDir(temporaryDir);
    for (const file of makeswiftFiles) {
        const relativePath = file.split(`${temporaryDir}/`)[1];
        const filePath = path_1.default.join(dir, relativePath);
        const filePathObject = path_1.default.parse(filePath);
        fs.mkdirSync(filePathObject.dir, { recursive: true });
        fs.copyFileSync(file, filePath);
    }
}
function readAllFilesInDir(dir) {
    function recursivelyReadFolder(dir, files) {
        const filesInDir = fs.readdirSync(dir);
        for (const file of filesInDir) {
            const fullFilepath = path_1.default.join(dir, file);
            if (fs.lstatSync(fullFilepath).isDirectory()) {
                recursivelyReadFolder(fullFilepath, files);
                continue;
            }
            files.push(fullFilepath);
        }
        return files;
    }
    const files = [];
    recursivelyReadFolder(dir, files);
    return files;
}
async function integrateNextApp({ dir }) {
    console.log('Integrating Next.js app');
    const isTS = isTypeScript({ dir });
    // Integrate pages in a temporary directory
    const temporaryDir = generateTemporaryApp({ dir });
    const pagesFolder = getPagesFolder({ dir, temporaryDir });
    // Step 1 - add Makeswift API route
    addMakeswiftApiRoute({ isTypeScript: isTS, pagesFolder });
    // Step 2 - add Makeswift pages
    addMakeswiftPages({ temporaryDir, isTypeScript: isTS, pagesFolder });
    // Step 3 - adding the Makeswift Next.js plugin
    addMakeswiftNextjsPlugin({ dir, temporaryDir });
    // Step 4 - install the runtime
    installMakeswiftRuntime({ dir });
    // Overwrite pages and next.config.js with output from temporary directory
    overwriteIntegratedFiles({ dir, temporaryDir });
}
exports.integrateNextApp = integrateNextApp;
function installMakeswiftRuntime({ dir }) {
    const packageManager = (0, yarn_or_npm_1.yarnOrNpm)(dir);
    if (packageManager === 'npm') {
        cross_spawn_1.default.sync('npm', ['install', '@makeswift/runtime'], {
            stdio: 'inherit',
            cwd: dir,
        });
    }
    else if (packageManager === 'yarn') {
        cross_spawn_1.default.sync('yarn', ['add', '@makeswift/runtime'], {
            stdio: 'inherit',
            cwd: dir,
        });
    }
}
function addMakeswiftApiRoute({ isTypeScript, pagesFolder, }) {
    const extension = isTypeScript ? 'ts' : 'js';
    fs.mkdirSync(path_1.default.join(pagesFolder.temporary, 'api', 'makeswift'), { recursive: true });
    const apiRoute = isTypeScript
        ? `import { MakeswiftApiHandler } from '@makeswift/runtime/next'

export default MakeswiftApiHandler(process.env.MAKESWIFT_SITE_API_KEY!)
`
        : `import { MakeswiftApiHandler } from '@makeswift/runtime/next'

export default MakeswiftApiHandler(process.env.MAKESWIFT_SITE_API_KEY)
`;
    fs.writeFileSync(path_1.default.join(pagesFolder.temporary, 'api', 'makeswift', `[...makeswift].${extension}`), apiRoute);
}
function addMakeswiftPages({ temporaryDir, isTypeScript, pagesFolder, }) {
    function generateCatchAllRoute(isTypeScript) {
        switch (isTypeScript) {
            case false:
                return `import '../lib/makeswift/register-components'

import { Makeswift, Page as MakeswiftPage } from '@makeswift/runtime/next'

export async function getStaticPaths() {
  const makeswift = new Makeswift(process.env.MAKESWIFT_SITE_API_KEY)
  const pages = await makeswift.getPages()

  return {
    paths: pages.map((page) => ({
      params: {
        path: page.path.split('/').filter((segment) => segment !== ''),
      },
    })),
    fallback: 'blocking',
  }
}

export async function getStaticProps(ctx) {
  const makeswift = new Makeswift(process.env.MAKESWIFT_SITE_API_KEY)
  const path = '/' + (ctx.params?.path ?? []).join('/')
  const snapshot = await makeswift.getPageSnapshot(path, {
    preview: ctx.preview,
  })

  if (snapshot == null) return { notFound: true }

  return { props: { snapshot } }
}

export default function Page({ snapshot }) {
  return <MakeswiftPage snapshot={snapshot} />
}`;
            case true:
                return `import '../lib/makeswift/register-components'

import { Makeswift } from '@makeswift/runtime/next'
import { GetStaticPathsResult, GetStaticPropsContext, GetStaticPropsResult } from 'next'

import { Page as MakeswiftPage, PageProps as MakeswiftPageProps } from '@makeswift/runtime/next'

type ParsedUrlQuery = { path?: string[] }

export async function getStaticPaths(): Promise<GetStaticPathsResult<ParsedUrlQuery>> {
  const makeswift = new Makeswift(process.env.MAKESWIFT_SITE_API_KEY!)
  const pages = await makeswift.getPages()

  return {
    paths: pages.map(page => ({
      params: { path: page.path.split('/').filter(segment => segment !== '') },
    })),
    fallback: 'blocking',
  }
}

type Props = MakeswiftPageProps

export async function getStaticProps(
  ctx: GetStaticPropsContext<ParsedUrlQuery>,
): Promise<GetStaticPropsResult<Props>> {
  const makeswift = new Makeswift(process.env.MAKESWIFT_SITE_API_KEY!)
  const path = '/' + (ctx.params?.path ?? []).join('/')
  const snapshot = await makeswift.getPageSnapshot(path, { preview: ctx.preview })

  if (snapshot == null) return { notFound: true }

  return { props: { snapshot } }
}

export default function Page({ snapshot }: Props) {
  return <MakeswiftPage snapshot={snapshot} />
}`;
        }
    }
    // catch all route
    const catchAllRoute = generateCatchAllRoute(isTypeScript);
    const extension = isTypeScript ? 'ts' : 'js';
    // catch-all-route does not exist
    if (glob_1.default.sync(path_1.default.join(pagesFolder.absolute, `\\[*\\].${extension}*`)).length === 0) {
        const useOptionalCatchAllRoute = !fs.existsSync(path_1.default.join(pagesFolder.absolute, `index.${extension}`)) &&
            !fs.existsSync(path_1.default.join(pagesFolder.absolute, `index.${extension}x`));
        let catchAllRouteFilename;
        if (useOptionalCatchAllRoute) {
            catchAllRouteFilename = `[[...path]].${extension}x`;
        }
        else {
            catchAllRouteFilename = `[...path].${extension}x`;
            console.log(`\nWe noticed you have an index page, therefore we have created a ${chalk_1.default.yellow('normal catch-all route')} in Next.js. This will not match the index route \`/\`.\nRead more about that here: ${chalk_1.default.blue('https://nextjs.org/docs/routing/dynamic-routes#catch-all-routes')}`);
        }
        fs.writeFileSync(path_1.default.join(pagesFolder.temporary, catchAllRouteFilename), catchAllRoute);
    }
    else {
        throw new MakeswiftError_1.default('A dynamic route already exists, you will have to manually integrate: https://www.makeswift.com/docs/guides/advanced-setup#custom-live-route');
    }
    // custom document
    if (fs.existsSync(path_1.default.join(pagesFolder.absolute, `_document.${extension}`)) ||
        fs.existsSync(path_1.default.join(pagesFolder.absolute, `_document.${extension}x`))) {
        throw new MakeswiftError_1.default(`A custom document already exists, you will have to manually integrate: ${chalk_1.default.blue('https://www.makeswift.com/docs/guides/advanced-setup#extending-the-custom-document')}`);
    }
    const customDocument = `export { Document as default } from '@makeswift/runtime/next'`;
    fs.writeFileSync(path_1.default.join(pagesFolder.temporary, `_document.${extension}`), customDocument);
    // register components file
    fs.mkdirSync(path_1.default.join(temporaryDir, 'lib', 'makeswift'), { recursive: true });
    const registerComponentsFile = `import { Style } from '@makeswift/runtime/controls'
import { ReactRuntime } from '@makeswift/runtime/react'
import { HelloWorld } from '../../components/hello-world'

// Register your components here!

ReactRuntime.registerComponent(HelloWorld, {
  type: 'hello-world',
  label: 'Hello, world!',
  props: {
    className: Style({ properties: Style.All }),
  },
})
`;
    fs.writeFileSync(path_1.default.join(temporaryDir, 'lib', 'makeswift', `register-components.${isTypeScript ? 'ts' : 'js'}`), registerComponentsFile);
    // hello world component
    fs.mkdirSync(path_1.default.join(temporaryDir, 'components'));
    if (isTypeScript) {
        fs.writeFileSync(path_1.default.join(temporaryDir, 'components', 'hello-world.tsx'), `import React from 'react'

type Props = {
  className?: string
}

export function HelloWorld({ className }: Props) {
  return <p className={className}>Hello, world!</p>
}
`);
    }
    else {
        fs.writeFileSync(path_1.default.join(temporaryDir, 'components', 'hello-world.jsx'), `import React from 'react'

      export function HelloWorld(props) {
  return <p {...props}>Hello, world!</p>
}
`);
    }
}
function getPagesFolder({ dir, temporaryDir }) {
    if (fs.existsSync(path_1.default.join(dir, 'pages'))) {
        return {
            absolute: path_1.default.join(dir, 'pages'),
            temporary: path_1.default.join(temporaryDir, 'pages'),
        };
    }
    if (fs.existsSync(path_1.default.join(dir, 'src/pages'))) {
        return {
            absolute: path_1.default.join(dir, '/src/pages'),
            temporary: path_1.default.join(temporaryDir, '/src/pages'),
        };
    }
    throw new MakeswiftError_1.default('Cannot find pages directory in Next.js app.');
}
function isTypeScript({ dir }) {
    function hasTSConfig(dir) {
        return fs.existsSync(path_1.default.join(dir, 'tsconfig.json'));
    }
    function hasTSDependency(dir) {
        const packageJsonFile = path_1.default.join(dir, 'package.json');
        if (fs.existsSync(packageJsonFile)) {
            const packageJson = require(packageJsonFile);
            const { dependencies, devDependencies } = packageJson;
            return 'typescript' in dependencies || 'typescript' in devDependencies;
        }
        return false;
    }
    if (hasTSConfig(dir) || hasTSDependency(dir)) {
        return true;
    }
    return false;
}
function addMakeswiftNextjsPlugin({ dir, temporaryDir }) {
    // @todo: support ES modules
    if (fs.existsSync(path_1.default.join(dir, 'next.config.mjs'))) {
        throw new MakeswiftError_1.default("We currently don't support automatic integration an ES modules Next.js config.");
    }
    const configFilename = path_1.default.join(dir, 'next.config.js');
    const writeLocation = path_1.default.join(temporaryDir, 'next.config.js');
    const alreadyExists = fs.existsSync(configFilename);
    if (!alreadyExists) {
        const nextConfig = `
const withMakeswift = require('@makeswift/runtime/next/plugin')()

/** @type {import('next').NextConfig} */
const nextConfig = {}

module.exports = withMakeswift(nextConfig)
    `;
        fs.writeFileSync(writeLocation, nextConfig);
        return;
    }
    const code = fs.readFileSync(configFilename).toString('utf-8');
    if (!(0, manipulate_next_config_1.isAlreadyIntegrated)(code)) {
        const outputCode = (0, manipulate_next_config_1.manipulateNextConfig)(code);
        fs.writeFileSync(writeLocation, outputCode);
    }
    else {
        throw new MakeswiftError_1.default(`The ${chalk_1.default.cyan('next.config.js')} appears to already be integrated. Did you mean to do this? The CLI needs a normal, unintegrated ${chalk_1.default.cyan('next.config.js')} in order to work.`);
    }
}
